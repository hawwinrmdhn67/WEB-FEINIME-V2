BEGIN;

-- ============================================================
-- 1) TABLE: profiles
-- ============================================================
CREATE TABLE IF NOT EXISTS public.profiles (
  id uuid PRIMARY KEY,
  email text,
  full_name text,
  avatar_url text,
  username text,
  updated_at timestamptz DEFAULT now()
);

-- Case-insensitive index for email lookups
CREATE INDEX IF NOT EXISTS idx_profiles_email_lower
  ON public.profiles (lower(email));

-- Normalize existing username to lowercase
UPDATE public.profiles
SET username = lower(username)
WHERE username IS NOT NULL AND username <> lower(username);

-- Fill username from auth.users if profile has none
UPDATE public.profiles p
SET username = lower(u.user_metadata ->> 'username')
FROM auth.users u
WHERE p.id = u.id
  AND (p.username IS NULL OR p.username = '')
  AND (u.user_metadata ->> 'username') IS NOT NULL;

-- AUTO LOWERCASE FUNCTION
CREATE OR REPLACE FUNCTION public.normalize_profile_username()
RETURNS trigger
LANGUAGE plpgsql
AS $$
BEGIN
  IF NEW.username IS NOT NULL THEN
    NEW.username := lower(NEW.username);
  END IF;
  RETURN NEW;
END;
$$;

-- TRIGGER
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_trigger
    WHERE tgname = 'trg_profiles_username_normalize'
      AND tgrelid = 'public.profiles'::regclass
  ) THEN
    CREATE TRIGGER trg_profiles_username_normalize
      BEFORE INSERT OR UPDATE ON public.profiles
      FOR EACH ROW
      EXECUTE FUNCTION public.normalize_profile_username();
  END IF;
END;
$$;

-- UNIQUE INDEX FOR USERNAME
CREATE UNIQUE INDEX IF NOT EXISTS idx_profiles_username_unique
  ON public.profiles (lower(username))
  WHERE username IS NOT NULL;

-- Enable RLS for profiles
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- POLICY: SELECT own profile
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM pg_policy
    WHERE polname = 'profiles_select_own'
      AND polrelid = 'public.profiles'::regclass
  ) THEN
    CREATE POLICY profiles_select_own ON public.profiles
      FOR SELECT
      USING (auth.uid() = id);
  END IF;
END$$;

-- POLICY: INSERT own profile
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM pg_policy
    WHERE polname = 'profiles_insert_own'
      AND polrelid = 'public.profiles'::regclass
  ) THEN
    CREATE POLICY profiles_insert_own ON public.profiles
      FOR INSERT
      WITH CHECK (auth.uid() = id);
  END IF;
END$$;

-- POLICY: UPDATE own profile
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM pg_policy
    WHERE polname = 'profiles_update_own'
      AND polrelid = 'public.profiles'::regclass
  ) THEN
    CREATE POLICY profiles_update_own ON public.profiles
      FOR UPDATE
      USING (auth.uid() = id)
      WITH CHECK (auth.uid() = id);
  END IF;
END$$;

-- ============================================================
-- 2) TABLE: user_anime_list
-- ============================================================
CREATE TABLE IF NOT EXISTS public.user_anime_list (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id uuid REFERENCES auth.users(id) NOT NULL,
  mal_id integer NOT NULL,
  status text,
  title text,
  image_url text,
  total_episodes integer,
  progress integer DEFAULT 0,
  score integer DEFAULT 0,
  created_at timestamptz DEFAULT now()
);

-- Unique constraint on (user_id, mal_id)
CREATE UNIQUE INDEX IF NOT EXISTS idx_user_anime_list_user_mal_unique
  ON public.user_anime_list (user_id, mal_id);

-- Performance indexes
CREATE INDEX IF NOT EXISTS idx_user_anime_list_user_created_at
  ON public.user_anime_list (user_id, created_at DESC);

CREATE INDEX IF NOT EXISTS idx_user_anime_list_user_mal
  ON public.user_anime_list (user_id, mal_id);

-- Normalize null progress/score
UPDATE public.user_anime_list SET progress = 0 WHERE progress IS NULL;
UPDATE public.user_anime_list SET score = 0 WHERE score IS NULL;

-- Enable RLS
ALTER TABLE public.user_anime_list ENABLE ROW LEVEL SECURITY;

-- POLICY: SELECT own rows
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM pg_policy
    WHERE polname = 'user_anime_select_own'
      AND polrelid = 'public.user_anime_list'::regclass
  ) THEN
    CREATE POLICY user_anime_select_own ON public.user_anime_list
      FOR SELECT
      USING (auth.uid() = user_id);
  END IF;
END$$;

-- POLICY: INSERT own rows
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM pg_policy
    WHERE polname = 'user_anime_insert_own'
      AND polrelid = 'public.user_anime_list'::regclass
  ) THEN
    CREATE POLICY user_anime_insert_own ON public.user_anime_list
      FOR INSERT
      WITH CHECK (auth.uid() = user_id);
  END IF;
END$$;

-- POLICY: UPDATE own rows
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM pg_policy
    WHERE polname = 'user_anime_update_own'
      AND polrelid = 'public.user_anime_list'::regclass
  ) THEN
    CREATE POLICY user_anime_update_own ON public.user_anime_list
      FOR UPDATE
      USING (auth.uid() = user_id)
      WITH CHECK (auth.uid() = user_id);
  END IF;
END$$;

-- POLICY: DELETE own rows
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM pg_policy
    WHERE polname = 'user_anime_delete_own'
      AND polrelid = 'public.user_anime_list'::regclass
  ) THEN
    CREATE POLICY user_anime_delete_own ON public.user_anime_list
      FOR DELETE
      USING (auth.uid() = user_id);
  END IF;
END$$;

COMMIT;
