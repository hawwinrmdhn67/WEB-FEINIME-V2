module.exports = [
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}),
"[project]/lib/api.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getAnimeByGenre",
    ()=>getAnimeByGenre,
    "getAnimeCharacters",
    ()=>getAnimeCharacters,
    "getAnimeDetail",
    ()=>getAnimeDetail,
    "getAnimeReviews",
    ()=>getAnimeReviews,
    "getAnimeStatistics",
    ()=>getAnimeStatistics,
    "getGenres",
    ()=>getGenres,
    "getMangaDetail",
    ()=>getMangaDetail,
    "getPopularAnime",
    ()=>getPopularAnime,
    "getSeasonNow",
    ()=>getSeasonNow,
    "getTopAnime",
    ()=>getTopAnime,
    "searchAnime",
    ()=>searchAnime
]);
const JIKAN_API_BASE = 'https://api.jikan.moe/v4';
// ==========================================
// 2. HELPER FUNCTIONS (RETRY LOGIC)
// ==========================================
const delay = (ms)=>new Promise((resolve)=>setTimeout(resolve, ms));
/**
 * Fungsi Fetch Pintar dengan Auto-Retry dan Exponential Backoff 
 * untuk menangani Rate Limit Jikan API (429).
 */ async function fetchWithRetry(url, options, retries = 3, backoff = 1000) {
    try {
        // Delay kecil global untuk menghindari rate limit agresif Jikan
        await delay(300);
        const res = await fetch(url, options);
        // Jika terkena Rate Limit (429), retry
        if (res.status === 429 && retries > 0) {
            console.warn(`[API] Rate limit hit for ${url}. Retrying in ${backoff}ms...`);
            await delay(backoff);
            return fetchWithRetry(url, options, retries - 1, backoff * 2);
        }
        return res;
    } catch (error) {
        // Retry pada error jaringan
        if (retries > 0) {
            await delay(backoff);
            return fetchWithRetry(url, options, retries - 1, backoff * 2);
        }
        throw error;
    }
}
async function getAnimeDetail(mal_id) {
    try {
        const res = await fetchWithRetry(`${JIKAN_API_BASE}/anime/${mal_id}/full`, {
            next: {
                revalidate: 3600
            }
        });
        if (res.status === 404) return null;
        if (!res.ok) return null;
        const data = await res.json();
        return data.data;
    } catch (error) {
        return null;
    }
}
async function getAnimeCharacters(mal_id) {
    try {
        const res = await fetchWithRetry(`${JIKAN_API_BASE}/anime/${mal_id}/characters`, {
            next: {
                revalidate: 3600
            }
        });
        if (!res.ok) return [];
        const data = await res.json();
        return data.data.sort((a, b)=>a.role === 'Main' ? -1 : 1).slice(0, 12);
    } catch (error) {
        return [];
    }
}
async function getAnimeReviews(mal_id) {
    try {
        const res = await fetchWithRetry(`${JIKAN_API_BASE}/anime/${mal_id}/reviews?preliminary=true&spoiler=false`, {
            next: {
                revalidate: 3600
            }
        });
        if (!res.ok) return [];
        const data = await res.json();
        return data.data.slice(0, 6);
    } catch (error) {
        return [];
    }
}
async function getAnimeStatistics(mal_id) {
    try {
        const res = await fetchWithRetry(`${JIKAN_API_BASE}/anime/${mal_id}/statistics`, {
            next: {
                revalidate: 3600
            }
        });
        if (!res.ok) return null;
        const data = await res.json();
        return data.data;
    } catch (error) {
        return null;
    }
}
async function getMangaDetail(mal_id) {
    try {
        const res = await fetchWithRetry(`${JIKAN_API_BASE}/manga/${mal_id}/full`, {
            next: {
                revalidate: 3600
            }
        });
        if (res.status === 404) return null;
        if (!res.ok) throw new Error('Failed');
        const data = await res.json();
        return data.data;
    } catch (error) {
        return null;
    }
}
async function getTopAnime() {
    try {
        const [res1, res2] = await Promise.all([
            fetchWithRetry(`${JIKAN_API_BASE}/top/anime?page=1&limit=25`, {
                next: {
                    revalidate: 3600
                }
            }),
            fetchWithRetry(`${JIKAN_API_BASE}/top/anime?page=2&limit=25`, {
                next: {
                    revalidate: 3600
                }
            })
        ]);
        if (!res1.ok || !res2.ok) throw new Error('Failed');
        const data1 = await res1.json();
        const data2 = await res2.json();
        return {
            data: [
                ...data1.data,
                ...data2.data
            ],
            pagination: data1.pagination
        };
    } catch (error) {
        return {
            data: []
        };
    }
}
async function getPopularAnime() {
    try {
        const [res1, res2] = await Promise.all([
            fetchWithRetry(`${JIKAN_API_BASE}/top/anime?filter=bypopularity&page=1&limit=25`, {
                next: {
                    revalidate: 3600
                }
            }),
            fetchWithRetry(`${JIKAN_API_BASE}/top/anime?filter=bypopularity&page=2&limit=25`, {
                next: {
                    revalidate: 3600
                }
            })
        ]);
        if (!res1.ok || !res2.ok) throw new Error('Failed');
        const data1 = await res1.json();
        const data2 = await res2.json();
        return {
            data: [
                ...data1.data,
                ...data2.data
            ],
            pagination: data1.pagination
        };
    } catch (error) {
        return {
            data: []
        };
    }
}
async function getSeasonNow(page = 1) {
    try {
        const res = await fetchWithRetry(`${JIKAN_API_BASE}/seasons/now?page=${page}&limit=25`, {
            next: {
                revalidate: 86400
            }
        });
        if (!res.ok) throw new Error('Failed');
        return await res.json();
    } catch (error) {
        return {
            data: []
        };
    }
}
async function searchAnime(query, page = 1, signal) {
    try {
        const url = `${JIKAN_API_BASE}/anime?q=${encodeURIComponent(query)}&page=${page}&limit=25&sfw=true`;
        // Pass signal ke fetchWithRetry agar request bisa di-cancel
        const res = await fetchWithRetry(url, {
            signal,
            next: {
                revalidate: 300
            }
        });
        if (!res.ok) return {
            data: []
        };
        return await res.json();
    } catch (error) {
        return {
            data: []
        };
    }
}
async function getGenres() {
    try {
        const res = await fetchWithRetry(`${JIKAN_API_BASE}/genres/anime`, {
            next: {
                revalidate: 86400
            }
        });
        if (!res.ok) throw new Error('Failed');
        const data = await res.json();
        return data.data;
    } catch (error) {
        return [];
    }
}
async function getAnimeByGenre(genreId) {
    try {
        const pages = [
            1,
            2,
            3,
            4,
            5
        ];
        const promises = pages.map((page)=>fetchWithRetry(`${JIKAN_API_BASE}/anime?genres=${genreId}&page=${page}&limit=25&order_by=start_date&sort=desc&sfw=true`, {
                next: {
                    revalidate: 3600
                }
            }).then((res)=>res.ok ? res.json() : {
                    data: []
                }));
        const results = await Promise.all(promises);
        const combinedData = results.flatMap((r)=>r.data || []);
        const uniqueData = Array.from(new Map(combinedData.map((item)=>[
                item.mal_id,
                item
            ])).values());
        return {
            data: uniqueData,
            pagination: {
                last_visible_page: 5,
                has_next_page: true,
                current_page: 1
            }
        };
    } catch (error) {
        return {
            data: []
        };
    }
}
}),
"[project]/lib/searchProxy.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getAnimeSearch",
    ()=>getAnimeSearch
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$api$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/api.ts [app-route] (ecmascript)");
;
const cache = new Map();
const queue = [];
let processing = false;
const MIN_REQUEST_INTERVAL = 1000 // 1 detik per request
;
async function processQueue() {
    if (processing) return;
    processing = true;
    while(queue.length > 0){
        const { query, resolve, reject } = queue.shift();
        try {
            if (cache.has(query)) resolve(cache.get(query));
            else {
                const data = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$api$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["searchAnime"])(query);
                cache.set(query, data.data);
                resolve(data.data);
            }
        } catch (err) {
            reject(err);
        }
        await new Promise((r)=>setTimeout(r, MIN_REQUEST_INTERVAL));
    }
    processing = false;
}
function getAnimeSearch(query) {
    return new Promise((resolve, reject)=>{
        queue.push({
            query,
            resolve,
            reject
        });
        processQueue();
    });
}
}),
"[project]/app/api/search/route.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GET",
    ()=>GET
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$searchProxy$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/searchProxy.ts [app-route] (ecmascript)");
;
;
async function GET(req) {
    const { searchParams } = new URL(req.url);
    const query = searchParams.get('q');
    if (!query) return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
        error: 'Query required'
    }, {
        status: 400
    });
    try {
        const data = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$searchProxy$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getAnimeSearch"])(query);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            data
        });
    } catch (err) {
        console.error('Server proxy search failed:', err);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: err.message || 'Failed to search'
        }, {
            status: 500
        });
    }
}
}),
];

//# sourceMappingURL=%5Broot-of-the-server%5D__f46107f8._.js.map